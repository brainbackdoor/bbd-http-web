HTTP 2.0은 지금까지 애플리케이션 내에서 HTTP 1.1을 보완하기 위해 구현헀던 기능을 전송 계층으로 옮김으로써 애플리케이션을 더 빠르고 안정적이고 단순하게 만들 것이다. 

기본 목표는 요청과 응답 멀티플렉싱을 통하여 레이턴ㅁ시를 줄이고 HTTP 헤더 필드를 효율적으로 압축하여 프로토콜 오버헤드를 최소화하며 요청 우선순위와 서버 푸쉬 기능을 지원하는 것이다.
이러한 기능을 도입하려면 흐름제어, 에러 핸들링, 업ㅂ그레이드 메커니즘 등 프로토콜에 추가적인 기능이 필요하다. 

HTTP 2.0은 HTTP 애플리케이션 기본 틀을 전혀 건드리지 않는다. HTTP 메서드, 상태코드, URI, 헤더필드 등 모든 핵심 개념이 그대로다. 그 대신 HTTP 2.0은 데이터의 구성과 전송 등의 과정을 모두 프로토콜에서 관리하게 하고 복잡한 구조는 프레이밍 계층에서 추성화시켜 애플리케이션에 영향을 끼치지 않도록했다. 그 결과 기존의 애플리케이션은 따로 수정을 거치지 않고도 HTTP 2.0을 사용할 수 있다.

SPDY의 역사
HTTP 2.0으로 가는길

..
- TCP를 사용하여 대부분의 경우 HTTP 1.1보다 대폭적으로 사용자단의 레이턴시를 개선해야 한다.
- HTTP의 문제점인 HOL 블로킹을 해결해야 한다.
- 병렬화를 위하여 서버에 다수의 커넥션을 요구하지 않고 특히 혼잡 제어에 있어서 TCP 사용 효율을 높여야 한다.
- 기존의 스펙 문서를 활용하여 HTTP 메서드, 상태 코드, URI, 헤더 필드를 비롯한 HTTP 1.1의 기본 틀은 유지해야 한다.
- HTTP 2.0이 HTTP 1.x과 어떻게 상호작용을 하는지 (특히 중계자 내에서) 명확하게 정의해야 한다.
특히 웹 브라우징(데스크톱과 모바일용), 브라우저 아닌 것들(HTTP API), 다양한 규모의 웹 서빙(web serving), 그리고 중계 (프락시, 방화벽,  리버스 프락시와 CDN)에 있어서는 더욱 그렇다. 
..

디자인과 기술적인 목표
- 바이너리 프레이밍 계층
//
메서드나 헤더같은 HTTP 시맨틱은 변하지 않았으나, 전송 중에 일어나는 인코딩 방식은 달라졌다. 개행으로 구분되던 단순 텍스트 HTTP 1.x 프로토콜과는 달리 HTTP 2.0 커뮤니케이션은 모두 바이너리 형식의 더 작은 메시지와 프레임으로 나뉜다.
//
- 스트림, 메시지 그리고 프레임
//
//// 그림
스트림 : 생성된 커넥션 내에서 발생하는 데이터의 양방향 흐름
메시지 : 논리적 메시지를 이루는 전체 프레임 시퀀스
프레임 : HTTP 2.0 커뮤니케이션에서 사용되는 가장 작은 단위로, 각 프레임이 어느 스트림에 속해있는지 지정하는 프레임 헤더를 포함하고 있다.
//

- 요청과 응답 멀티 플렉싱
HTTP 1.x에서는 클라이언트가 성능 개선을 위해 다수의 요청을 병렬로 생성하려면 여러 개의 TCP 커넥션을 사용해야만 한다. 이는 커넥션당 한 번에 하나의 응답만을 전달하는 HTTP 1.x 전달모델(응답 큐잉)때문이다.
HTTP 2.0에서 도입된 바이너리 프레이밍 계층은 HTTP 메시지를 독립적인 프레임으로 쪼개어 전달한 후 수신 측에서 재구성하기 떄문에 완전한 요청과 응답 멀티플렉싱이 가능하다.
HTTP 메시지를 독립적인 프레임으로 분할하고 교차 삽입하여 수신측에서 재구성할 수 있도록 한 것이 HTTP 2.0에서 가장 중요한 개선사항이다. (HOL 블로킹 문제를 해결했고 요청과 응답을 병렬로 처리하기 위해 여러 개의 커넥션을 사용할 필요도 없어졌다.)
- 요청 우선순위
서버는 CPU, 메모리, 대역폭 등의 리소스 할당을 관리함으로써 스트림 프로세싱을 우선할 수 있고, 응답 데이터가 준비되면 우선순위가 높은 프레임을 클라이언트에게 우선하여 전달하도록 할 수 있다. 이 때  HTTP 2.0은 우선순위를 정할 떄에 특별한 알고리즘을 정하지는 않고, 그저 클라이언트와 서버 간 우선순위에 따라 데이터 교환이 이루어지는 메커니즘만을 제공한다. 
그러나 우선순위를 엄격하게 정하는 것도 최적의 시나리오는 아니다. 하나의 느린 요청이 다른 모든 리소스의 전달을 불필요하게 블로킹시켜 HOL 블로킹 문제를 유발할 수 있기 때문이다.

- 요청 지점당 하나의 커넥션
// 
모든 스트림 간에 일관적인 우선순위
단일 압축 컨텍스트를 통한 향상된 압축률
TCP 커넥션을 줄임으로써 네트워크 혼잡을 개선
느린 시작(slow-start) 시간 단축과 빠른 혼잡 및 손실 복구
//
HTTP 에서는 HOL 블로킹을 없앴지만 TCP 레벨에서는 여전히 HOL qmffhzlddl whswogksek.
패킷 손실이 일어났을 때 TCP 혼잡 윈도의 크기가 줄어들어 전체 커넥션의 최대 처리량이 감소한다.

그러나 HOL 블로킹에서 오는 단점은 압축률과 우선순위의 장점으로 메꿔진다.
또한,
TCP Fast Open, 초기 혼잡 윈도 크기 증가 등 TCP 성능 향상을 시키는 다른 방안들도.
//
- 흐름제어
//
동일한 TCP 커넥션상에서 여러 스트림을 멀티플렉싱하면 공유 대역폭 리소스를 두고 경쟁이 일어날 수 있다.
흐름제어는 종단이 아닌 Hop 사이에서 작동한다. 흐름 제어는 윈도 업데이트 프레임에 기반하고 있다. 수신자가 전체 커넥션에서 얼만큼의 데이터를 받을 준비가 되어 있는지 통지한다. 스트림 ID와 윈도 크기 증가값을 정하는 WINDOW_UPDATE 프레임 흐름제어 윈도 크기를 업데이트 한다.
//
- 서버 푸시
서버가 클라이언트 요청 하나에 대하여 여러 개의 응답을 보낼 수 있는 기능. 즉 본래의 요청에 대한 응답 뿐만 아니라 클라이언트가 일일이 개별 요청을 따로 보내지 않아도 서버가 추가적인 리소스를 푸시해줄 수 있는 것을 의미한다.
//
푸시된 리소스는 클라이언트 쪽에서 캐시에 저장할 수 있다. 
푸시된 리소스는 클라이언트 쪽에서 거부할 수 있다.
푸시된 리소스는 여러 페이지에 걸쳐 재사용할 수 있다.
푸시된 리소스는 서버 쪽에서 우선순위를 정할 수 있다.
//
PUSH_PROMISE

1. 서버가 요청-응답 사이클에 따라 작동하기 때문에 오직 요청이 있을 때만 그 응답으로서 리소스를 푸시할 수 있다.
2. 클라이언트와 경쟁 상황(race condition)을 만들지 않기 위하여, PUSH_PROMISE 프레임은 반드시 응답을 받기 전에 먼저 전송해야 한다.
//
- 헤더 압축
- 효율적인 HTTP 2.0 업그레이드와 새로운 발견

바이너리 프레이밍의 간략한 소개
- 새 스트림 생성하기
- 애플리케이션 데이터 전송하기
- HTTP 2.0 프레임 데이터 흐름 분석하기